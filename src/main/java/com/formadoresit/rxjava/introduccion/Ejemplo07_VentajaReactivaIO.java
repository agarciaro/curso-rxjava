package com.formadoresit.rxjava.introduccion;

import io.reactivex.Observable;
import io.reactivex.schedulers.Schedulers;

import java.util.*;
import java.util.concurrent.*;
import java.util.stream.Collectors;

/**
 * INTRODUCCI√ìN - Ejemplo 07: Ventaja Real de Programaci√≥n Reactiva
 * 
 * CASO DE USO REAL: Sistema de Recomendaci√≥n de Productos E-commerce
 * 
 * Escenario:
 * - M√∫ltiples llamadas a APIs/servicios (I/O bound)
 * - Necesidad de combinar datos de diferentes fuentes
 * - Timeouts y manejo de errores
 * - Operaciones que pueden ejecutarse en paralelo
 * 
 * Este ejemplo muestra la VERDADERA ventaja de la programaci√≥n reactiva:
 * - Operaciones I/O no bloqueantes
 * - Ejecuci√≥n paralela autom√°tica
 * - Composici√≥n elegante de operaciones as√≠ncronas
 * - Manejo de errores declarativo
 * - Cancelaci√≥n de operaciones
 * 
 * DIFERENCIA CLAVE:
 * - Imperativa: Secuencial, bloqueante, cada llamada espera a la anterior
 * - Reactiva: Paralela, no bloqueante, todas las llamadas al mismo tiempo
 */
public class Ejemplo07_VentajaReactivaIO {

    // ==================== MODELOS DE DATOS ====================

    static class User {
        final int id;
        final String name;
        final String category;

        User(int id, String name, String category) {
            this.id = id;
            this.name = name;
            this.category = category;
        }

        @Override
        public String toString() {
            return String.format("User{id=%d, name='%s', category='%s'}", id, name, category);
        }
    }

    static class Purchase {
        final int productId;
        final String productName;
        final double price;

        Purchase(int productId, String productName, double price) {
            this.productId = productId;
            this.productName = productName;
            this.price = price;
        }

        @Override
        public String toString() {
            return String.format("Purchase{id=%d, name='%s', $%.2f}", productId, productName, price);
        }
    }

    static class Product {
        final int id;
        final String name;
        final String category;
        final double rating;

        Product(int id, String name, String category, double rating) {
            this.id = id;
            this.name = name;
            this.category = category;
            this.rating = rating;
        }

        @Override
        public String toString() {
            return String.format("Product{id=%d, name='%s', cat='%s', rating=%.1f}", 
                id, name, category, rating);
        }
    }

    static class Recommendation {
        final Product product;
        final double score;
        final String reason;

        Recommendation(Product product, double score, String reason) {
            this.product = product;
            this.score = score;
            this.reason = reason;
        }

        @Override
        public String toString() {
            return String.format("üí° %s (score: %.2f) - %s", 
                product.name, score, reason);
        }
    }

    // ==================== SERVICIOS SIMULADOS (APIs) ====================

    /**
     * Simula llamada a API de Usuarios (delay 500ms)
     */
    static class UserService {
        static User getUserProfile(int userId) {
            System.out.println("  üîµ [" + Thread.currentThread().getName() + "] Llamando User API...");
            simulateNetworkDelay(500);
            System.out.println("  ‚úÖ [" + Thread.currentThread().getName() + "] User API respondi√≥");
            return new User(userId, "Juan P√©rez", "Electronics");
        }

        static Observable<User> getUserProfileAsync(int userId) {
            return Observable.fromCallable(() -> {
                System.out.println("  üü¢ [" + Thread.currentThread().getName() + "] Llamando User API (async)...");
                simulateNetworkDelay(500);
                System.out.println("  ‚úÖ [" + Thread.currentThread().getName() + "] User API respondi√≥");
                return new User(userId, "Juan P√©rez", "Electronics");
            }).subscribeOn(Schedulers.io());
        }
    }

    /**
     * Simula llamada a API de Historial de Compras (delay 800ms)
     */
    static class PurchaseHistoryService {
        static List<Purchase> getPurchaseHistory(int userId) {
            System.out.println("  üîµ [" + Thread.currentThread().getName() + "] Llamando Purchase History API...");
            simulateNetworkDelay(800);
            System.out.println("  ‚úÖ [" + Thread.currentThread().getName() + "] Purchase History API respondi√≥");
            return Arrays.asList(
                new Purchase(101, "Laptop HP", 899.99),
                new Purchase(102, "Mouse Logitech", 29.99),
                new Purchase(103, "Teclado Mec√°nico", 89.99)
            );
        }

        static Observable<List<Purchase>> getPurchaseHistoryAsync(int userId) {
            return Observable.fromCallable(() -> {
                System.out.println("  üü¢ [" + Thread.currentThread().getName() + "] Llamando Purchase History API (async)...");
                simulateNetworkDelay(800);
                System.out.println("  ‚úÖ [" + Thread.currentThread().getName() + "] Purchase History API respondi√≥");
                return Arrays.asList(
                    new Purchase(101, "Laptop HP", 899.99),
                    new Purchase(102, "Mouse Logitech", 29.99),
                    new Purchase(103, "Teclado Mec√°nico", 89.99)
                );
            }).subscribeOn(Schedulers.io());
        }
    }

    /**
     * Simula llamada a API de Productos Populares (delay 600ms)
     */
    static class ProductCatalogService {
        static List<Product> getPopularProducts(String category) {
            System.out.println("  üîµ [" + Thread.currentThread().getName() + "] Llamando Product Catalog API...");
            simulateNetworkDelay(600);
            System.out.println("  ‚úÖ [" + Thread.currentThread().getName() + "] Product Catalog API respondi√≥");
            return Arrays.asList(
                new Product(201, "Monitor 4K Samsung", "Electronics", 4.7),
                new Product(202, "Webcam Logitech", "Electronics", 4.5),
                new Product(203, "Auriculares Sony", "Electronics", 4.8),
                new Product(204, "SSD 1TB", "Electronics", 4.6)
            );
        }

        static Observable<List<Product>> getPopularProductsAsync(String category) {
            return Observable.fromCallable(() -> {
                System.out.println("  üü¢ [" + Thread.currentThread().getName() + "] Llamando Product Catalog API (async)...");
                simulateNetworkDelay(600);
                System.out.println("  ‚úÖ [" + Thread.currentThread().getName() + "] Product Catalog API respondi√≥");
                return Arrays.asList(
                    new Product(201, "Monitor 4K Samsung", "Electronics", 4.7),
                    new Product(202, "Webcam Logitech", "Electronics", 4.5),
                    new Product(203, "Auriculares Sony", "Electronics", 4.8),
                    new Product(204, "SSD 1TB", "Electronics", 4.6)
                );
            }).subscribeOn(Schedulers.io());
        }
    }

    /**
     * Simula llamada a API de Tendencias (delay 700ms)
     */
    static class TrendingService {
        static List<Product> getTrendingProducts() {
            System.out.println("  üîµ [" + Thread.currentThread().getName() + "] Llamando Trending API...");
            simulateNetworkDelay(700);
            System.out.println("  ‚úÖ [" + Thread.currentThread().getName() + "] Trending API respondi√≥");
            return Arrays.asList(
                new Product(301, "iPhone 15", "Electronics", 4.9),
                new Product(302, "AirPods Pro", "Electronics", 4.7)
            );
        }

        static Observable<List<Product>> getTrendingProductsAsync() {
            return Observable.fromCallable(() -> {
                System.out.println("  üü¢ [" + Thread.currentThread().getName() + "] Llamando Trending API (async)...");
                simulateNetworkDelay(700);
                System.out.println("  ‚úÖ [" + Thread.currentThread().getName() + "] Trending API respondi√≥");
                return Arrays.asList(
                    new Product(301, "iPhone 15", "Electronics", 4.9),
                    new Product(302, "AirPods Pro", "Electronics", 4.7)
                );
            }).subscribeOn(Schedulers.io());
        }
    }

    // ==================== SOLUCI√ìN IMPERATIVA S√çNCRONA ====================

    static class ImperativeSyncSolution {
        
        /**
         * Genera recomendaciones de forma IMPERATIVA S√çNCRONA
         * Problema: Cada llamada BLOQUEA hasta que termine
         * Total: 500 + 800 + 600 + 700 = 2600ms m√≠nimo
         */
        static List<Recommendation> generateRecommendations(int userId) {
            long startTime = System.currentTimeMillis();
            System.out.println("\nüîµ SOLUCI√ìN IMPERATIVA S√çNCRONA - Secuencial y Bloqueante");
            System.out.println("‚îÄ".repeat(60));

            // Llamada 1: Obtener perfil de usuario (500ms)
            User user = UserService.getUserProfile(userId);

            // Llamada 2: Obtener historial (800ms) - ESPERA a que termine la anterior
            List<Purchase> purchases = PurchaseHistoryService.getPurchaseHistory(userId);

            // Llamada 3: Obtener cat√°logo (600ms) - ESPERA a que termine la anterior
            List<Product> catalog = ProductCatalogService.getPopularProducts(user.category);

            // Llamada 4: Obtener trending (700ms) - ESPERA a que termine la anterior
            List<Product> trending = TrendingService.getTrendingProducts();

            // Procesar recomendaciones
            List<Recommendation> recommendations = processRecommendations(user, purchases, catalog, trending);

            long duration = System.currentTimeMillis() - startTime;
            System.out.println("\n‚è±Ô∏è  Tiempo total: " + duration + "ms");
            System.out.println("üìä Eficiencia: Ejecut√≥ 4 llamadas SECUENCIALMENTE");
            
            return recommendations;
        }
    }

    // ==================== SOLUCI√ìN IMPERATIVA AS√çNCRONA ====================

    static class ImperativeAsyncSolution {
        
        /**
         * Genera recomendaciones de forma IMPERATIVA AS√çNCRONA con CompletableFuture
         * Ventaja: Las llamadas se ejecutan en PARALELO
         * Problema: C√≥digo verboso, dif√≠cil de leer, propenso a errores
         * Total: max(500, 800, 600, 700) = 800ms (similar a reactiva)
         */
        static List<Recommendation> generateRecommendations(int userId) throws ExecutionException, InterruptedException {
            long startTime = System.currentTimeMillis();
            System.out.println("\nüü° SOLUCI√ìN IMPERATIVA AS√çNCRONA - Paralela con CompletableFuture");
            System.out.println("‚îÄ".repeat(60));

            ExecutorService executor = Executors.newFixedThreadPool(4);

            try {
                // Iniciar todas las llamadas EN PARALELO usando CompletableFuture
                CompletableFuture<User> userFuture = CompletableFuture.supplyAsync(() -> {
                    System.out.println("  üü° [" + Thread.currentThread().getName() + "] Llamando User API (async)...");
                    simulateNetworkDelay(500);
                    System.out.println("  ‚úÖ [" + Thread.currentThread().getName() + "] User API respondi√≥");
                    return new User(userId, "Juan P√©rez", "Electronics");
                }, executor);

                CompletableFuture<List<Purchase>> purchasesFuture = CompletableFuture.supplyAsync(() -> {
                    System.out.println("  üü° [" + Thread.currentThread().getName() + "] Llamando Purchase History API (async)...");
                    simulateNetworkDelay(800);
                    System.out.println("  ‚úÖ [" + Thread.currentThread().getName() + "] Purchase History API respondi√≥");
                    return Arrays.asList(
                        new Purchase(101, "Laptop HP", 899.99),
                        new Purchase(102, "Mouse Logitech", 29.99),
                        new Purchase(103, "Teclado Mec√°nico", 89.99)
                    );
                }, executor);

                // Cat√°logo depende del usuario, usar thenCompose
                CompletableFuture<List<Product>> catalogFuture = userFuture.thenComposeAsync(user -> 
                    CompletableFuture.supplyAsync(() -> {
                        System.out.println("  üü° [" + Thread.currentThread().getName() + "] Llamando Product Catalog API (async)...");
                        simulateNetworkDelay(600);
                        System.out.println("  ‚úÖ [" + Thread.currentThread().getName() + "] Product Catalog API respondi√≥");
                        return Arrays.asList(
                            new Product(201, "Monitor 4K Samsung", "Electronics", 4.7),
                            new Product(202, "Webcam Logitech", "Electronics", 4.5),
                            new Product(203, "Auriculares Sony", "Electronics", 4.8),
                            new Product(204, "SSD 1TB", "Electronics", 4.6)
                        );
                    }, executor)
                , executor);

                CompletableFuture<List<Product>> trendingFuture = CompletableFuture.supplyAsync(() -> {
                    System.out.println("  üü° [" + Thread.currentThread().getName() + "] Llamando Trending API (async)...");
                    simulateNetworkDelay(700);
                    System.out.println("  ‚úÖ [" + Thread.currentThread().getName() + "] Trending API respondi√≥");
                    return Arrays.asList(
                        new Product(301, "iPhone 15", "Electronics", 4.9),
                        new Product(302, "AirPods Pro", "Electronics", 4.7)
                    );
                }, executor);

                // Combinar todos los resultados - C√ìDIGO VERBOSO
                CompletableFuture<List<Recommendation>> combinedFuture = 
                    CompletableFuture.allOf(userFuture, purchasesFuture, catalogFuture, trendingFuture)
                        .thenApply(v -> {
                            try {
                                System.out.println("\n  üéØ Todas las APIs respondieron - Procesando...");
                                User user = userFuture.get();
                                List<Purchase> purchases = purchasesFuture.get();
                                List<Product> catalog = catalogFuture.get();
                                List<Product> trending = trendingFuture.get();
                                
                                return processRecommendations(user, purchases, catalog, trending);
                            } catch (Exception e) {
                                throw new RuntimeException(e);
                            }
                        });

                List<Recommendation> recommendations = combinedFuture.get();

                long duration = System.currentTimeMillis() - startTime;
                System.out.println("\n‚è±Ô∏è  Tiempo total: " + duration + "ms");
                System.out.println("üìä Eficiencia: Ejecut√≥ 4 llamadas EN PARALELO");
                System.out.println("‚ö†Ô∏è  Complejidad: ~40 l√≠neas de c√≥digo, verboso, propenso a errores");

                return recommendations;

            } finally {
                executor.shutdown();
            }
        }
    }

    /**
     * M√©todo helper para procesar recomendaciones (usado por todas las soluciones)
     */
    private static List<Recommendation> processRecommendations(
            User user, List<Purchase> purchases, List<Product> catalog, List<Product> trending) {
        
        List<Recommendation> recommendations = new ArrayList<>();
        
        Set<Integer> purchasedIds = purchases.stream()
            .map(p -> p.productId)
            .collect(Collectors.toSet());

        catalog.stream()
            .filter(p -> !purchasedIds.contains(p.id))
            .forEach(p -> recommendations.add(new Recommendation(
                p, p.rating * 10, "Popular en " + user.category
            )));

        trending.stream()
            .filter(p -> !purchasedIds.contains(p.id))
            .forEach(p -> recommendations.add(new Recommendation(
                p, p.rating * 12, "Trending ahora"
            )));

        return recommendations;
    }

    // ==================== SOLUCI√ìN REACTIVA ====================

    static class ReactiveSolution {
        
        /**
         * Genera recomendaciones de forma REACTIVA con RxJava
         * Ventaja: Todas las llamadas en PARALELO con c√≥digo ELEGANTE
         * Total: max(500, 800, 600, 700) = 800ms (similar a CompletableFuture)
         * Diferencia: C√ìDIGO SIMPLE, COMPOSABLE, MANTENIBLE
         */
        static List<Recommendation> generateRecommendations(int userId) throws InterruptedException {
            long startTime = System.currentTimeMillis();
            System.out.println("\nüü¢ SOLUCI√ìN REACTIVA (RxJava) - Paralela, Elegante y Declarativa");
            System.out.println("‚îÄ".repeat(60));

            // ‚ö° ELEGANCIA DE RxJava: Todas las llamadas en PARALELO con c√≥digo simple
            List<Recommendation> recommendations = Observable.zip(
                UserService.getUserProfileAsync(userId),
                PurchaseHistoryService.getPurchaseHistoryAsync(userId),
                Observable.defer(() -> 
                    UserService.getUserProfileAsync(userId)
                        .flatMap(user -> ProductCatalogService.getPopularProductsAsync(user.category))
                ),
                TrendingService.getTrendingProductsAsync(),
                
                // Combinar resultados - C√ìDIGO LIMPIO Y LEGIBLE
                (user, purchases, catalog, trending) -> {
                    System.out.println("\n  üéØ Todas las APIs respondieron - Procesando...");
                    return processRecommendations(user, purchases, catalog, trending);
                }
            )
            .timeout(5, TimeUnit.SECONDS)
            .onErrorReturn(error -> {
                System.err.println("  ‚ùå Error: " + error.getMessage());
                return Collections.emptyList();
            })
            .blockingFirst();

            long duration = System.currentTimeMillis() - startTime;
            System.out.println("\n‚è±Ô∏è  Tiempo total: " + duration + "ms");
            System.out.println("üìä Eficiencia: Ejecut√≥ 4 llamadas EN PARALELO");
            System.out.println("‚ú® Elegancia: ~15 l√≠neas de c√≥digo, simple, mantenible");
            
            return recommendations;
        }
    }

    // ==================== UTILIDADES ====================

    private static void simulateNetworkDelay(int ms) {
        try {
            Thread.sleep(ms);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }

    // ==================== MAIN ====================

    public static void main(String[] args) throws InterruptedException, ExecutionException {
        System.out.println("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó");
        System.out.println("‚ïë  VENTAJA REAL DE PROGRAMACI√ìN REACTIVA                     ‚ïë");
        System.out.println("‚ïë  Caso: Sistema de Recomendaci√≥n de Productos              ‚ïë");
        System.out.println("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù");
        
        int userId = 12345;
        
        System.out.println("\nüìã Escenario:");
        System.out.println("  ‚Ä¢ 4 llamadas a diferentes APIs/servicios");
        System.out.println("  ‚Ä¢ User API: 500ms");
        System.out.println("  ‚Ä¢ Purchase History API: 800ms");
        System.out.println("  ‚Ä¢ Product Catalog API: 600ms");
        System.out.println("  ‚Ä¢ Trending API: 700ms");
        System.out.println("\n‚ùì ¬øCu√°l es m√°s r√°pida?");

        // ==================== TEST 1: IMPERATIVA S√çNCRONA ====================
        long syncStart = System.currentTimeMillis();
        List<Recommendation> syncResults = ImperativeSyncSolution.generateRecommendations(userId);
        long syncDuration = System.currentTimeMillis() - syncStart;

        System.out.println("\nüì¶ Recomendaciones encontradas: " + syncResults.size());
        syncResults.forEach(r -> System.out.println("  " + r));

        Thread.sleep(1000);

        // ==================== TEST 2: IMPERATIVA AS√çNCRONA ====================
        long asyncStart = System.currentTimeMillis();
        List<Recommendation> asyncResults = ImperativeAsyncSolution.generateRecommendations(userId);
        long asyncDuration = System.currentTimeMillis() - asyncStart;

        System.out.println("\nüì¶ Recomendaciones encontradas: " + asyncResults.size());
        asyncResults.forEach(r -> System.out.println("  " + r));

        Thread.sleep(1000);

        // ==================== TEST 3: REACTIVA ====================
        long reactiveStart = System.currentTimeMillis();
        List<Recommendation> reactiveResults = ReactiveSolution.generateRecommendations(userId);
        long reactiveDuration = System.currentTimeMillis() - reactiveStart;

        System.out.println("\nüì¶ Recomendaciones encontradas: " + reactiveResults.size());
        reactiveResults.forEach(r -> System.out.println("  " + r));

        // ==================== COMPARACI√ìN FINAL ====================
        System.out.println("\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó");
        System.out.println("‚ïë                  COMPARACI√ìN DE LAS 3 SOLUCIONES           ‚ïë");
        System.out.println("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£");
        System.out.println("‚ïë                                                            ‚ïë");
        System.out.println("‚ïë  1Ô∏è‚É£  IMPERATIVA S√çNCRONA (Secuencial)                      ‚ïë");
        System.out.println(String.format("‚ïë      Tiempo:  %8dms                                      ‚ïë", syncDuration));
        System.out.println("‚ïë      C√≥digo:  Simple pero LENTO                           ‚ïë");
        System.out.println("‚ïë      Threads: 1 thread (bloqueante)                       ‚ïë");
        System.out.println("‚ïë                                                            ‚ïë");
        System.out.println("‚ïë  2Ô∏è‚É£  IMPERATIVA AS√çNCRONA (CompletableFuture)             ‚ïë");
        System.out.println(String.format("‚ïë      Tiempo:  %8dms                                      ‚ïë", asyncDuration));
        System.out.println("‚ïë      C√≥digo:  ~40 l√≠neas, VERBOSO, complejo              ‚ïë");
        System.out.println("‚ïë      Threads: Pool de threads                             ‚ïë");
        System.out.println("‚ïë                                                            ‚ïë");
        System.out.println("‚ïë  3Ô∏è‚É£  REACTIVA (RxJava)                                     ‚ïë");
        System.out.println(String.format("‚ïë      Tiempo:  %8dms                                      ‚ïë", reactiveDuration));
        System.out.println("‚ïë      C√≥digo:  ~15 l√≠neas, ELEGANTE, simple               ‚ïë");
        System.out.println("‚ïë      Threads: Pool autom√°tico con Schedulers              ‚ïë");
        System.out.println("‚ïë                                                            ‚ïë");
        System.out.println("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£");
        System.out.println("‚ïë                                                            ‚ïë");
        
        double speedupSync = (double) syncDuration / reactiveDuration;
        double speedupAsync = (double) asyncDuration / reactiveDuration;
        
        System.out.println(String.format("‚ïë  üöÄ vs S√≠ncrona:  %.2fx m√°s r√°pida                          ‚ïë", speedupSync));
        System.out.println(String.format("‚ïë  ‚öñÔ∏è  vs As√≠ncrona: %.2fx (similar en tiempo)                 ‚ïë", speedupAsync));
        System.out.println("‚ïë                                                            ‚ïë");
        System.out.println("‚ïë  üí° VENTAJA DE RxJava:                                     ‚ïë");
        System.out.println("‚ïë     ‚Ä¢ Mismo rendimiento que CompletableFuture             ‚ïë");
        System.out.println("‚ïë     ‚Ä¢ Pero con 2-3x MENOS c√≥digo                          ‚ïë");
        System.out.println("‚ïë     ‚Ä¢ C√≥digo m√°s LEGIBLE y MANTENIBLE                     ‚ïë");
        System.out.println("‚ïë     ‚Ä¢ Operadores COMPONIBLES                              ‚ïë");
        System.out.println("‚ïë     ‚Ä¢ Manejo de errores DECLARATIVO                       ‚ïë");
        System.out.println("‚ïë                                                            ‚ïë");
        System.out.println("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù");

        System.out.println("\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó");
        System.out.println("‚ïë              COMPARACI√ìN DE COMPLEJIDAD DE C√ìDIGO          ‚ïë");
        System.out.println("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£");
        System.out.println("‚ïë                                                            ‚ïë");
        System.out.println("‚ïë  üü° IMPERATIVA AS√çNCRONA (CompletableFuture):             ‚ïë");
        System.out.println("‚ïë                                                            ‚ïë");
        System.out.println("‚ïë  ExecutorService executor = Executors.newFixedThreadPool‚ïë");
        System.out.println("‚ïë  CompletableFuture<User> userFuture =                     ‚ïë");
        System.out.println("‚ïë      CompletableFuture.supplyAsync(() -> {...}, executor)‚ïë");
        System.out.println("‚ïë  CompletableFuture<List<Purchase>> purchasesFuture =      ‚ïë");
        System.out.println("‚ïë      CompletableFuture.supplyAsync(() -> {...}, executor)‚ïë");
        System.out.println("‚ïë  CompletableFuture<List<Product>> catalogFuture =         ‚ïë");
        System.out.println("‚ïë      userFuture.thenComposeAsync(user ->                  ‚ïë");
        System.out.println("‚ïë          CompletableFuture.supplyAsync(...), executor);   ‚ïë");
        System.out.println("‚ïë  CompletableFuture<List<Product>> trendingFuture =        ‚ïë");
        System.out.println("‚ïë      CompletableFuture.supplyAsync(() -> {...}, executor)‚ïë");
        System.out.println("‚ïë  CompletableFuture.allOf(...).thenApply(v -> {            ‚ïë");
        System.out.println("‚ïë      try {                                                 ‚ïë");
        System.out.println("‚ïë          User user = userFuture.get();                     ‚ïë");
        System.out.println("‚ïë          List<Purchase> purchases = purchasesFuture.get(); ‚ïë");
        System.out.println("‚ïë          // ... procesar ...                               ‚ïë");
        System.out.println("‚ïë      } catch (Exception e) { ... }                         ‚ïë");
        System.out.println("‚ïë  }).get();                                                 ‚ïë");
        System.out.println("‚ïë  executor.shutdown();                                      ‚ïë");
        System.out.println("‚ïë                                                            ‚ïë");
        System.out.println("‚ïë  üìä ~40 l√≠neas, verboso, propenso a errores               ‚ïë");
        System.out.println("‚ïë                                                            ‚ïë");
        System.out.println("‚ïë  üü¢ REACTIVA (RxJava):                                     ‚ïë");
        System.out.println("‚ïë                                                            ‚ïë");
        System.out.println("‚ïë  Observable.zip(                                           ‚ïë");
        System.out.println("‚ïë      UserService.getUserProfileAsync(userId),              ‚ïë");
        System.out.println("‚ïë      PurchaseHistoryService.getPurchaseHistoryAsync(...),  ‚ïë");
        System.out.println("‚ïë      ProductCatalogService.getPopularProductsAsync(...),   ‚ïë");
        System.out.println("‚ïë      TrendingService.getTrendingProductsAsync(),           ‚ïë");
        System.out.println("‚ïë      (user, purchases, catalog, trending) -> {             ‚ïë");
        System.out.println("‚ïë          return processRecommendations(...);               ‚ïë");
        System.out.println("‚ïë      }                                                      ‚ïë");
        System.out.println("‚ïë  )                                                          ‚ïë");
        System.out.println("‚ïë  .timeout(5, TimeUnit.SECONDS)                             ‚ïë");
        System.out.println("‚ïë  .onErrorReturn(error -> Collections.emptyList())          ‚ïë");
        System.out.println("‚ïë  .blockingFirst();                                         ‚ïë");
        System.out.println("‚ïë                                                            ‚ïë");
        System.out.println("‚ïë  üìä ~15 l√≠neas, elegante, f√°cil de entender               ‚ïë");
        System.out.println("‚ïë                                                            ‚ïë");
        System.out.println("‚ïë  ‚ú® RxJava: MISMO RENDIMIENTO, MENOS C√ìDIGO               ‚ïë");
        System.out.println("‚ïë                                                            ‚ïë");
        System.out.println("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù");

        System.out.println("\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó");
        System.out.println("‚ïë                    VENTAJAS DE RxJava                      ‚ïë");
        System.out.println("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£");
        System.out.println("‚ïë                                                            ‚ïë");
        System.out.println("‚ïë  1. ‚ö° PARALELISMO AUTOM√ÅTICO                              ‚ïë");
        System.out.println("‚ïë     Observable.zip() ejecuta todo en paralelo             ‚ïë");
        System.out.println("‚ïë                                                            ‚ïë");
        System.out.println("‚ïë  2. üéØ COMPOSICI√ìN ELEGANTE                                ‚ïë");
        System.out.println("‚ïë     Combina m√∫ltiples streams con operadores              ‚ïë");
        System.out.println("‚ïë                                                            ‚ïë");
        System.out.println("‚ïë  3. üõ°Ô∏è  MANEJO DE ERRORES DECLARATIVO                     ‚ïë");
        System.out.println("‚ïë     onErrorReturn() maneja errores sin try-catch          ‚ïë");
        System.out.println("‚ïë                                                            ‚ïë");
        System.out.println("‚ïë  4. ‚è∞ TIMEOUTS INTEGRADOS                                 ‚ïë");
        System.out.println("‚ïë     timeout() evita esperas infinitas                     ‚ïë");
        System.out.println("‚ïë                                                            ‚ïë");
        System.out.println("‚ïë  5. üßµ SCHEDULERS AUTOM√ÅTICOS                              ‚ïë");
        System.out.println("‚ïë     subscribeOn(Schedulers.io()) maneja threads           ‚ïë");
        System.out.println("‚ïë                                                            ‚ïë");
        System.out.println("‚ïë  6. üö´ CANCELACI√ìN F√ÅCIL                                   ‚ïë");
        System.out.println("‚ïë     dispose() cancela todas las operaciones               ‚ïë");
        System.out.println("‚ïë                                                            ‚ïë");
        System.out.println("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù");

        System.out.println("\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó");
        System.out.println("‚ïë                    CASOS DE USO IDEALES                    ‚ïë");
        System.out.println("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£");
        System.out.println("‚ïë                                                            ‚ïë");
        System.out.println("‚ïë  ‚úÖ APIs REST que llaman a m√∫ltiples servicios            ‚ïë");
        System.out.println("‚ïë  ‚úÖ Microservicios con operaciones I/O                    ‚ïë");
        System.out.println("‚ïë  ‚úÖ Consultas a bases de datos en paralelo                ‚ïë");
        System.out.println("‚ïë  ‚úÖ Sistemas de recomendaci√≥n                             ‚ïë");
        System.out.println("‚ïë  ‚úÖ Agregaci√≥n de datos de m√∫ltiples fuentes             ‚ïë");
        System.out.println("‚ïë  ‚úÖ Streaming de datos en tiempo real                     ‚ïë");
        System.out.println("‚ïë  ‚úÖ Operaciones con timeouts y reintentos                 ‚ïë");
        System.out.println("‚ïë                                                            ‚ïë");
        System.out.println("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù");

        System.out.println("\nüéì CONCLUSI√ìN:");
        System.out.println("\n   ‚ùì ¬øPor qu√© RxJava si CompletableFuture tambi√©n es r√°pido?");
        System.out.println("\n   ‚úÖ VENTAJAS DE RxJava:");
        System.out.println("      1. C√ìDIGO M√ÅS SIMPLE: 15 l√≠neas vs 40 l√≠neas");
        System.out.println("      2. M√ÅS LEGIBLE: Estilo declarativo vs imperativo");
        System.out.println("      3. COMPONIBLE: Operadores se encadenan f√°cilmente");
        System.out.println("      4. MANEJO DE ERRORES: onErrorReturn() vs try-catch");
        System.out.println("      5. TIMEOUTS: Integrado vs manual");
        System.out.println("      6. CANCELACI√ìN: dispose() vs complex shutdown logic");
        System.out.println("      7. +300 OPERADORES: map, filter, flatMap, retry, etc.");
        System.out.println("      8. MANTENIBILIDAD: F√°cil de modificar y extender");
        System.out.println("\n   üí° RxJava = Performance + Elegancia + Mantenibilidad");
    }
}

